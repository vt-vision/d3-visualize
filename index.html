<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>3D Force-Directed Graph</title>
    <style>
        body {
            margin: 0;
        }
    </style>
    <script src="https://unpkg.com/3d-force-graph"></script>
    <script src="https://unpkg.com/three"></script>
    <script src="//unpkg.com/three-spritetext"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
</head>

<body>
    <div id="3d-graph"></div>
</body>

</html>

<script type="importmap">
  { "imports": { "three": "https://unpkg.com/three/build/three.module.js" } }
</script>
<script type="module">
    import {
        CSS2DRenderer,
        CSS2DObject,
    } from "https://unpkg.com/three/examples/jsm/renderers/CSS2DRenderer.js";


    var graph;
    d3.json("./graph.json").then(function (loadedGraph) {
        graph = loadedGraph; // assuming graph.json contains your graph structure
        
        const highlightNodes = new Set();
        const highlightLinks = new Set();
        let hoverNode = null;

        graph.links.forEach(link => {
            const a = graph.nodes.find(e => e.id == link.source);
            const b = graph.nodes.find(e => e.id == link.target);
            !a.neighbors && (a.neighbors = []);
            !b.neighbors && (b.neighbors = []);
            a.neighbors.push(b);
            b.neighbors.push(a);
      
            !a.links && (a.links = []);
            !b.links && (b.links = []);
            a.links.push(link);
            b.links.push(link);
          });

        const Graph = ForceGraph3D()(document.getElementById("3d-graph"))
            .graphData(graph)
            .nodeLabel("amr_token") // text shown when mouse over a node
            .nodeAutoColorBy("group") // color nodes by group
            .onNodeClick((node) => {
                // Aim at node from outside it
                const distance = 60;
                const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);

                Graph.cameraPosition(
                    {
                        x: node.x * distRatio,
                        y: node.y * distRatio,
                        z: node.z * distRatio,
                    }, // new position
                    node, // lookAt ({ x, y, z })
                    3000 // ms transition duration
                );
            })
            .onNodeDragEnd((node) => {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            })
            .linkThreeObjectExtend(true)
            .linkThreeObject((link) => {
                // extend link with text sprite
                const sprite = new SpriteText(`${link.edge_info}`);
                sprite.color = "lightgrey";
                sprite.textHeight = 1.5;
                sprite.fontSize = 100;
                return sprite;
            })
            .linkPositionUpdate((sprite, { start, end }) => {
                const middlePos = Object.assign(
                    ...["x", "y", "z"].map((c) => ({
                        [c]: start[c] + (end[c] - start[c]) / 2, // calc middle point
                    }))
                );
                // Position sprite
                Object.assign(sprite.position, middlePos);
            })
            // highlight nodes and connections of hovered node
            // color the node by the group otherwise
            // TODO: fix the color of the node
            .nodeColor(node => highlightNodes.has(node) ? node === hoverNode ? 'rgb(255,0,0,1)' : 'rgba(255,160,0,0.8)' : null)
            .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
            .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
            .linkDirectionalParticleWidth(4)
            .onNodeHover(node => {
                document.body.style.cursor = node ? "pointer" : null
                // no state change
                if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

                highlightNodes.clear();
                highlightLinks.clear();
                if (node) {
                    highlightNodes.add(node);
                    node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                    node.links.forEach(link => highlightLinks.add(link));
                }

                hoverNode = node || null;

                updateHighlight();
            })
            .onLinkHover(link => {
                highlightNodes.clear();
                highlightLinks.clear();

                if (link) {
                    highlightLinks.add(link);
                    highlightNodes.add(link.source);
                    highlightNodes.add(link.target);
                }

                updateHighlight();
            });

        Graph.nodeThreeObject((node) => {
            if (node.image) {
                // Create a texture for the image
                const imgTexture = new THREE.TextureLoader().load(node.image);
                imgTexture.colorSpace = THREE.SRGBColorSpace;
                // Create a sphere to represent the node
                const material = new THREE.SpriteMaterial({ map: imgTexture });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(40, 40);
                return sprite;
            } else {
                return null;
            }
        });

        function updateHighlight() {
            // trigger update of highlighted objects in scene
            Graph
                .nodeColor(Graph.nodeColor())
                .linkWidth(Graph.linkWidth())
                .linkDirectionalParticles(Graph.linkDirectionalParticles());
        }
    });
</script>