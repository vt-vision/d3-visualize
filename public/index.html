<!DOCTYPE html>
<html lang="en">

<style>
    .node-label {
        background-color: rgba(0, 0, 0, 0.5);
        user-select: none;
    }
</style>

<head>
    <meta charset="UTF-8" />
    <title>3D Force-Directed Graph</title>
    <style>
        body {
            margin: 0;
        }
    </style>
    <script src="https://unpkg.com/3d-force-graph"></script>
    <script src="https://unpkg.com/three"></script>
    <script src="//unpkg.com/three-spritetext"></script>
    <script src="//unpkg.com/dat.gui"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
</head>

<body>
    <div id="3d-graph"></div>
</body>

</html>

<script type="importmap">
  { "imports": { "three": "https://unpkg.com/three/build/three.module.js" } }
</script>
<script type="module">
    import {
        CSS2DRenderer,
        CSS2DObject,
    } from "https://unpkg.com/three/examples/jsm/renderers/CSS2DRenderer.js";
    //import { UnrealBloomPass } from '//unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';


    var graph;
    d3.json("./graph_merge_groups.json").then(function (loadedGraph) {
        const graph = ForceGraph3D({
            extraRenderers: [new CSS2DRenderer()],
        })(document.getElementById("3d-graph"))
            .graphData(loadedGraph)
            .nodeLabel('word_token')
            .linkLabel(link => {
                if (link.edge_info.startsWith(":snt")) {
                    return null;
                } else {
                    return `${link.source.amr_token} <-> ${link.target.amr_token}`
                }
            })
            .nodeAutoColorBy("group") // color nodes by group
            .linkAutoColorBy(d => {
                if (d.edge_info == ":coref") {
                    return "red";
                } else {
                    return loadedGraph.nodes.find(e => {
                        return e.id == d.source;
                    }).group;
                }
            }) // color links with their source node color
            .linkOpacity(0.5)
            .onNodeClick((node) => {
                // Aim at node from outside it
                const distance = 70;
                const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);

                graph.cameraPosition(
                    {
                        x: node.x * distRatio,
                        y: node.y * distRatio,
                        z: node.z * distRatio,
                    }, // new position
                    node, // lookAt ({ x, y, z })
                    3000 // ms transition duration
                );
            })
            .onNodeDragEnd((node) => {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            })
            .linkThreeObjectExtend(true)
            .linkPositionUpdate((sprite, { start, end }) => {
                const middlePos = Object.assign(
                    ...["x", "y", "z"].map((c) => ({
                        [c]: start[c] + (end[c] - start[c]) / 2, // calc middle point
                    }))
                );
                // Position sprite
                Object.assign(sprite.position, middlePos);
            })
            .onNodeHover(node => {
                document.body.style.cursor = node ? "pointer" : null;
            });

        graph.nodeThreeObjectExtend(true);
        graph.nodeThreeObject(createNodeObject);
        graph.linkThreeObject(createLinkLabel);

        function createNodeObject(node) {
            if (node.image) {
                // Create a texture for the image
                const imgTexture = new THREE.TextureLoader().load(node.image);
                imgTexture.colorSpace = THREE.SRGBColorSpace;
                // Create a sphere to represent the node
                const material = new THREE.SpriteMaterial({ map: imgTexture });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(45, 45);
                return sprite;
            } else {
                const sprite = new SpriteText(node.amr_token);
                sprite.material.depthWrite = false; // make sprite background transparent
                sprite.color = node.color;
                sprite.textHeight = 8;
                
                return sprite;
            }
        }

        function createLinkLabel(link) {
            if (link.edge_info.startsWith(":snt")) {
                // TODO
                return new SpriteText("");
            }

            const sprite = new SpriteText(`${link.edge_info}`);
            sprite.color = "lightgrey";
            sprite.textHeight = 1.5;

            if (link.edge_info == ":coref") {
                sprite.color = "red";
                sprite.textHeight = 2;
            }

            return sprite;
        }

        //Define GUI
        const Settings = function () {
            this.nodeSize = 10;
            this.linkWidth = 3;
            
            //this.distance = 20;
            //this.fontSize = 6;
        };


        const settings = new Settings();
        const gui = new dat.GUI();

        const nodeSizeController = gui.add(settings, 'nodeSize', 0, 40);
        const linkWidthController = gui.add(settings, 'linkWidth', 0, 30);
        

        nodeSizeController.onChange(() => {
            graph.nodeRelSize(settings.nodeSize);
        });
        linkWidthController.onChange(() => {
            graph.linkWidth(settings.linkWidth);
        });
        
        //const linkForce = graph
        //    .d3Force('link')
        //    .distance(link => settings.distance);
        //const distanceController = gui.add(settings, 'distance', 0, 100);
        //const fontSizeController = gui.add(settings, 'fontSize', 0, 20);
        //distanceController.onChange(() => {
        //    linkForce.distance(link => settings.distance);
        //    graph.numDimensions(3); // Re-heat simulation
        //});
        // TODO adjust the font size
        //fontSizeController.onChange(() => {
            // When fontSize changes, re-create the labels with the new size
         //   graph.nodeThreeObject(createNodeObject);
         //   graph.linkThreeObject(createLinkLabel);

            // Refresh the graph to reflect changes
        //    graph.refresh();
        //});
        


        // for fun
        //----------------------------------------
        //const bloomPass = new UnrealBloomPass();
        //bloomPass.strength = 1;
        //bloomPass.radius = 0.5;
        //bloomPass.threshold = 0;
        //graph.postProcessingComposer().addPass(bloomPass);
        //----------------------------------------
    });
</script>